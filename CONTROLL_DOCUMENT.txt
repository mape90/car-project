
Ohjaus looppi rakentuun kahdesta osasta, joista ensimmäisessä osassa luetaaan etusensorien arvoja puskurin ja lasketaan biteille keskiarvot siten, että jokaiselle bitille lasketaan summa, kuinka monta kertaa se on ollut päällä jokaisella puskurissa olevassa lukuarvossa. Jos bitti on ollu päällä yli puolet kaikista puskuriarvoista, niin bitti tulkitaan ykköseksi, muuten sen on nolla. Tämä filtteröity arvo sioitetaan globaaliin muuttujaan gBumperValue.
Toisessa luupin ossassa tarkistetaan ollaanko odottavassa vai ajavassa tilassa. Odottavassa tilassa kirjoitetaan auton moottoreille suoraan 0 PWM arvoa joka tarkoittaa sitä että pwm on nolla ja moottori ohjain on asettanut molemman moottorin navat maahan.
Ajavassa tilassa suoritetaan seuraavanlainen ohjaus laskenta. Aluksi lasketaan gBumperValue:sta calcError funktion avulla mikä on auton tämän hetkinen tila. Ensimmäiseksi funktio laskeen gBumperValue:sta vasemman ja oikeanpuoleisimmat bitit, jotka ovat päällä. Tämän avulla voidaan määrittää onko havainto maalilinja vai viiva havainto. Jos nähdään, että kyseessä on maalilinja asetetaan virheeksi 0, muutoin asetetaan se arvo, joka ollaan nähty ja vain tällöin päivitetään muuttujaa joka pitää kirjaa edellisestä arvosta. Jos puskuri ei ole nähnyt mitään pidetään virhe samana kuin edellisessä havainnossa, paitsi jos viiva ollaan hävitetty jommalta kummalta reunimmaisista sensoreista, tällöin asetetaan tilaksi CONTROL_NO_REF_POINT mikä ilmaisee, että auto on kadottanut radan.

Kun virhe on tiedossa annetaan tämä arvo funktiolle control_calc() missä määritetän moottorin ja servon ohjaus. Jos virhe on ensimmäisen kerran CONTROL_NO_REF_POINT asetetaan ajastin päälle. Ajastin asettaa auton pysäytettyyn tilaan, jos auto ei tiettyyn aikamääreeseen mennessä onnistu näkemään viivaa uudestaan. Tässä tilassa auto ohjaa samalla tapaan kuin havaitessaan viivan uloimmalla sensorilla. Jos virhe on taas GOAL_POINT käsitellään tilannetta samaan tapaan kuin virhe olisi nollan. Muutoin virhe annetaan suoraan ohjauksen laskeville funktioille. Mikä servon tapauksesa on ainoastaan pid-säädiin. Moottorille taas kutsutaan funktiota calcMotorSpeed(), mikä toimii P-säätimen tapaan hidastaen auton nopeutta kun vihe kasvaa.

control_calc() funktion jälkeen annetaan ohajuskulma ja haluttu nopeus control_execute() funktiolle joka ensin asettaa servon uuteen asentoon  servo_writeControl() funktiolla, mikä muuttaa asteissa olevan virheen PWM singnaaliksi ja asettaa sen servolle uudeksi ohajuskulmaksi. Tämän jälkeen motor_setSpeed() avulla asetetaan moottorin nopeus.

motor_setSpeed() funktio lukee tachometriltä sykäykset tachometer_read() funktiolla. Tämä funktio lukee tachometrin sykäyksiä laskevasta laskurilta uuden arvon ja sioittaa sen rengas puskuriin. Rengas puskurin sykäykset lasketaan yhteen ja palautetaan.

Kun uudet sykäykset on saatu muutetaan ne RPM muotoon tachometer_value2rpm() funktiolla. Tämän jälkeen tarkistetaan, onko annettu rpm arvo 0, jos on niin pysäytetään moottori, muuten lasketaan PID-säätimellä uusi ohjaus arvo ja kirjoitetaan se moottorille.

PID-säätimenä käytetään Atmelin esimerkki säädintä, johon on lisätty integer windup. Sillä alkuperäinen säädin ainoastaan tarkasit etteivät arvo pääse aiheuttamaan owerflowta.
